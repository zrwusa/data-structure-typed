# CONCEPTS: 核心基础与理论

本指南通过平实的语言和实用理解来解释数据结构背后的基础概念。

**👈 [返回 README](../README_CN.md) • [API 参考](./REFERENCE_CN.md) • [实战指南](./GUIDES_CN.md)**

---

## 目录

1. [三大核心概念](#三大核心概念)
2. [平实的语言解释](#-平实的语言解释)
3. [Iterator 协议设计](#iterator-协议设计)
4. [无缝互操作性](#-无缝互操作性iterator-协议随处可得)
5. [所有 Array 方法到处都有效](#-所有-array-方法到处都有效)
6. [为什么不直接使用原生 JavaScript？](#为什么不直接使用原生-javascript)
7. [决策指南](#-决策指南选择正确的数据结构)

---

## 三大核心概念

### 1. **Binary Search Tree (BST)** — O(log n) 搜索/插入/删除

通过保持所有左子节点小于当前节点，所有右子节点大于当前节点来维护排序顺序。

```javascript
// 属性：对于任何节点
// 所有左子树的值 < 节点值
// 所有右子树的值 > 节点值

//        5
//       / \
//      3   8
//     / \   \
//    1   4   9
```

**优势**：快速操作，无需预排序
**权衡**：不平衡的树会降级到 O(n)

### 2. **Balanced Trees (AVL, Red-Black)** — 自动重新平衡

自动重组自身以保证 O(log n) 即使在插入/删除后。

```javascript
// Red-Black Tree: 颜色规则确保平衡
// AVL Tree: 高度差 ≤ 1

// 两者：插入 = O(log n), 删除 = O(log n), 搜索 = O(log n) 总是
```

**优势**：保证 O(log n) 性能
**成本**：每次修改都有重新平衡的开销

### 3. **Heap** — 父子优先级关系

一个完整的二叉树，其中父节点总是优先于子节点。

```javascript
// Max Heap:     // Min Heap:
//      9             1
//     / \           / \
//    7   8         2   3
//   / \           / \
//  3   2         8   9

// 父节点 = 比子节点优先级高 1.5 倍
// 根总是具有最佳优先级
```

**优势**：获取最高/最低优先级非常快
**完美用于**：优先级队列、堆排序

---

## 🌍 平实的语言解释

对于喜欢通过比喻理解概念的人：

| 数据结构         | 平实的定义                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 例子                                                        |
|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------:|
| **Linked List**        | 一排兔子，每只兔子都拉着前面兔子的尾巴。你想找到一只叫 Pablo 的兔子，你必须从第一只兔子开始搜索。如果不是 Pablo，你继续跟着那只兔子的尾巴去下一只。所以，你可能需要搜索 n 次才能找到 Pablo (O(n) 时间复杂度)。如果你想在 Pablo 和 Vicky 之间插入一只叫 Remi 的兔子，这很简单。你只需要让 Vicky 放开 Pablo 的尾巴，让 Remi 拉住 Pablo 的尾巴，然后让 Vicky 拉住 Remi 的尾巴 (O(1) 时间复杂度)。                                                                                          | 要找到兔子"Pablo"，从第一只兔子开始并跟着尾巴直到找到 |
| **Array**              | 一排编号的兔子。如果你想找到叫 Pablo 的兔子，你可以直接喊出 Pablo 的号码 0680（通过数组索引直接找到元素，O(1) 时间复杂度）。但是，如果你不知道 Pablo 的号码，你仍然需要逐个搜索（O(n) 时间复杂度）。此外，如果你想在 Pablo 后面添加一只叫 Vicky 的兔子，你需要给 Vicky 后面的所有兔子重新编号（O(n) 时间复杂度）。                                                                                                                                                                                                                                                                                                    | 通过索引查找元素是即时的，但在中间插入很慢       |
| **Queue**              | 一排编号的兔子，第一只兔子上贴着一张便签。对于这排带便签的兔子，每当我们想从队伍前面移除一只兔子时，我们只需将便签移到下一只兔子的脸上，而无需实际移除兔子以避免给后面的所有兔子重新编号（从前面移除也是 O(1) 时间复杂度）。对于队伍的末尾，我们不用担心，因为每只添加到末尾的新兔子直接被赋予一个新号码（O(1) 时间复杂度），而无需给所有之前的兔子重新编号。                                    | 以 FIFO 顺序处理项目，从两端高效处理                        |
| **Deque**              | 一排分组的、编号的兔子，第一只兔子上贴着一张便签。对于这排兔子，我们通过分组管理它。每次我们从队伍前面移除一只兔子时，我们只是将便签移到下一只兔子。这样，我们不需要每次都给第一只兔子后面的所有兔子重新编号。只有当一个分组的所有成员都被移除时，我们才重新分配号码和重新分组。末尾以类似的方式处理。这是一种延迟和批量操作的策略，以抵消 Array 数据结构在插入或删除中间元素时需要移动所有后面元素的缺点。 | 从两端高效地移除/插入，带批处理优化          |
| **Stack**              | 一排兔子在一个死胡同的隧道里，兔子只能从隧道入口（末尾）移除，新兔子也只能在入口（末尾）添加。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 以 LIFO 顺序处理项目；撤销/重做功能                           |
| **Binary Tree**        | 一棵树，其中每个节点最多有两个子节点。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 分层数据组织                                                 |
| **Binary Search Tree** | 一棵树，其中左子树的所有节点都小于该节点，右子树的所有节点都大于该节点。为所有操作维护 O(log n)。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 高效的搜索/插入/删除，无需重新排序                             |
| **Red-Black Tree**     | 一棵自平衡的 BST，通过颜色编码规则自动维护平衡。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 在 Java TreeMap 中使用，维护 O(log n) 保证                         |
| **AVL Tree**           | 一棵比红黑树更严格的自平衡 BST。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | 最大搜索速度，更慢的插入/删除                          |
| **Heap**               | 一棵存储在数组中的特殊二叉树，其中父节点总是与子节点保持优先级关系。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | 高效的优先级队列；堆排序                                    |
| **Trie**               | 一棵用于基于前缀搜索的字符树。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | 自动完成、拼写检查                                           |
| **Graph**              | 由边连接的顶点（节点）网络。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | 模型关系、网络                                               |

---

## Iterator 协议设计

### 隐藏的超能力

本库中的每一个数据结构都实现了 **Iterator 协议**：

- ✅ 扩展运算符：`[...tree]`
- ✅ for...of 循环：`for (const item of tree)`
- ✅ 解构：`const [a, b, c] = tree`
- ✅ Array.from()：`Array.from(tree)`
- ✅ Set/Map 构造器：`new Set(tree)`

### Iterator 支持比较

| 功能              | Array | Map  | Set | 其他库 | data-structure-typed |
|----------------------|-------|------|-----|-----------|----------------------|
| 扩展运算符      | ✅     | ❌/⚠️ | ✅   | ❌/⚠️      | ✅                    |
| for...of 循环        | ✅     | ✅    | ✅   | ❌/⚠️      | ✅                    |
| 解构        | ✅     | ❌    | ❌   | ❌         | ✅                    |
| Array.from()         | ✅     | ❌/⚠️ | ❌   | ❌/⚠️      | ✅                    |
| Set 构造器      | ✅     | ❌    | ✅   | ❌         | ✅                    |
| **完整集成** | ✅     | ⚠️   | ⚠️  | ⚠️        | **✅**                |

### 实时例子：零摩擦转换

#### 例子 1: Array 转 Tree 再转 Array

```javascript
const array = [64, 34, 25, 12, 22, 11, 90];
// Array 转 RedBlackTree
const rbTree = new RedBlackTree(array);
// Tree 转排序的 Array
const sorted = [...rbTree.keys()];
console.log(sorted);  // [11, 12, 22, 25, 34, 64, 90] ✅
```

#### 例子 2: 提取键和值

```javascript
const rbTree = new RedBlackTree([
  [1, 'Alice'],
  [2, 'Bob'],
  [3, 'Charlie']
]);

// 获取所有键
const allKeys = [...rbTree.keys()];      // [1, 2, 3]
// 获取所有值
const allValues = [...rbTree.values()];  // ['Alice', 'Bob', 'Charlie']
```

---

## 🌐 无缝互操作性：Iterator 协议随处可得

每个数据结构都能与标准 JavaScript 功能无缝配合工作。

### 与原生 Set 整合

```javascript
const tree = new RedBlackTree([3, 1, 4, 1, 5, 9, 2]);
// 直接传递给 Set 构造器
const uniqueSorted = new Set(tree.keys());
console.log([...uniqueSorted]); // [1, 2, 3, 4, 5, 9]
```

### 与 for...of 循环

```javascript
const tree = new RedBlackTree([[1, 'a'], [2, 'b']]);
for (const [key, value] of tree) {
  console.log(`${key}: ${value}`);
  // 输出：
  // 1: a
  // 2: b
}
```

---

## ✨ 所有 Array 方法到处都有效

所有树、队列、堆都支持 Array 的熟悉方法：`filter`、`map`、`reduce`、`forEach` 等。

```javascript
const tree = new RedBlackTree([5, 2, 8, 1, 9]);

// 使用熟悉的 Array 方法
const result = tree
  .filter(x => x > 2)           // [5, 8, 9]
  .map(x => x * 2)              // [10, 16, 18]
  .reduce((a, b) => a + b, 0);  // 44

// 树的优势仍然存在！
```

---

## 为什么不直接使用原生 JavaScript？

### 性能

原生 Array 和 Map 对某些操作很快，但对其他操作则很慢：

| 操作 | Array | Map | 数据结构库 |
|---------|-------|-----|------------|
| 查找 | O(n) | O(1) | O(log n) 或 O(1) |
| 排序插入 | O(n) | ❌ | O(log n) |
| 按范围查询 | O(n) | ❌ | O(log n) |
| 优先级访问 | O(n) | ❌ | O(1) |

### 便利性

使用我们的库，你不需要：
- 手动排序
- 跟踪索引
- 实现自己的树逻辑
- 处理平衡问题

---

## 🎯 决策指南：选择正确的数据结构

| 我需要做什么？ | 推荐使用 |
|-----------------------------------|---------|
| 排序的集合，支持快速查找 | RedBlackTree |
| 优先级队列 | MaxHeap 或 MinHeap |
| 前 K 个元素 | MaxHeap |
| FIFO 队列，带高效删除 | Deque 或 Queue |
| LIFO 栈 | Stack |
| 前缀搜索（自动完成） | Trie |
| 已排序的范围查询 | RedBlackTree |
| 频繁的插入/删除，需要排序 | RedBlackTree |
| 简单的优先级队列 | PriorityQueue |

---

**准备好代码了吗？** 查看 [GUIDES_CN.md](./GUIDES_CN.md) 了解实战例子。

**想知道性能吗？** 查看 [PERFORMANCE_CN.md](./PERFORMANCE_CN.md) 了解基准测试。