# Coverage milestone (2026-02-12)

Full-suite run:

- Test suites: 139 passed
- Tests: 1677 passed
- Coverage totals:
  - Lines: 97.39%
  - Statements: 97.46%
  - Functions: 94.25%
  - Branches: 98.43% (2900/2946)

Remaining uncovered branch counts (from coverage-summary.json):

- src/data-structures/binary-tree/red-black-tree.ts: 32
- src/data-structures/binary-tree/bst.ts: 13
- src/data-structures/base/linear-base.ts: 1 (suspected Istanbul/source-map counting artifact)

Latest work included:

- Added `red-black-tree.more-branches-3.coverage.test.ts` to cover reachable insertion min/max cache else-if branches and force `setWithHintNode` cache RHS evaluation across all 4 ultra-fast attach variants.
- Added `bst.more-branches-5.coverage.test.ts` to cover `BST.search()` key-pruning short-circuit branches (via safe, restored `_isPredicate` toggle).
- Added `red-black-tree.more-branches-4.coverage.test.ts` to cover `setWithHintNode` header cache nullish-coalescing RHS (`header._left/_right ?? NIL`) across all 4 ultra-fast attach variants.

## Notes on remaining uncovered branches (reachable-only policy)

The following remaining uncovered branches appear **structurally unreachable** under the current public API / internal call graph. Per the “reachable-only” policy, they were not forced with unsafe state fabrication.

### `src/data-structures/binary-tree/bst.ts`

1) `search()` range predicate guard `if (!node) return false;` (around line ~701)

- The DFS hook is `shouldProcessRoot = cur => !!cur && predicate(cur)`.
- Therefore `predicate(cur)` is only called when `cur` is truthy, so `predicate(undefined|null)` never happens.

2) `shouldVisitLeft/Right` early guard `if (!cur) return false;` (around lines ~710 / ~728)

- In `_dfs` (iterative), children are pushed only when `shouldVisitLeft/Right(cur.node)` is true.
- In `BST.search()`, `shouldVisitLeft/Right` first checks `isRealNode(cur.left/right)` and returns false otherwise.
- So DFS never pushes `undefined/null` as a VISIT node, and the `!cur` guard is never exercised.

3) `floor()` / `lower()` tail guard `if (typeof callback === 'string' || !callback) return undefined;` (around lines ~1173 / ~1278)

- This code is in the “no targetKey extracted” tail path.
- However, all inputs that would prevent extracting a target key are already returned earlier (e.g. entry with nullish key), and the remaining fall-through assigns `targetKey = keyNodeEntryOrPredicate`.
- Net effect: this tail guard is effectively unreachable.

### `src/data-structures/binary-tree/red-black-tree.ts`

1) `_deleteFixup` main loop branches (around lines ~1162–1202)

- The current entry guard + loop condition are mutually exclusive (the function returns early for states that would be required to enter the `while` loop).
- Attempting a CLRS-style correction changed observable deletion behavior and broke existing tests, so this block is treated as structurally unreachable for coverage purposes unless the implementation is intentionally revised.

2) Insertion min/max cache else-if branches (around lines ~623 / ~625):
   `else if (parent === hMax && lastCompared > 0)` and `else if (parent === hMin && lastCompared < 0)`

- These branches would require a “new extreme” insertion *while* also bypassing the earlier boundary-attach fast paths.
- Under normal invariants, those prerequisites conflict (a true new extreme with an empty extreme slot is handled by boundary attach; if the slot is not empty, the parent cannot be the extreme).
- Therefore they appear structurally unreachable without corrupting invariants.
