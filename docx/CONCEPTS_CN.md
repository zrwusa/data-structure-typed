# 概念：核心基础和理论

本指南通过简洁的语言和实际理解来解释数据结构背后的基本概念。

**👈 [回到 README](../README_CN.md) • [API 参考](./REFERENCE_CN.md) • [实战指南](./GUIDES_CN.md)**

---

## 目录

1. [三大核心概念](#三大核心概念)
2. [简洁的解释](#-简洁的解释)
3. [迭代器协议设计](#迭代器协议设计)
4. [无缝互操作性](#-无缝互操作性迭代器协议无处不在)
5. [所有数组方法都适用](#-所有数组方法都适用)
6. [为什么不直接用原生 JavaScript？](#为什么不直接用原生-javascript)
7. [决策指南](#-决策指南选择正确的数据结构)

---

## 三大核心概念

### 1. **二叉搜索树 (BST)** — O(log n) 搜索/插入/删除

通过保持所有左子节点小于节点，所有右子节点大于节点来维护排序顺序。

```javascript
// 属性：对于任何节点
// 所有左子树值 < 节点值
// 所有右子树值 > 节点值

//        5
//       / \
//      3   8
//     / \ /  \
//    1  4 9  ...
```

**优势**：无需预排序即可快速操作  
**权衡**：不平衡的树会降低到 O(n)

### 2. **平衡树（AVL、红黑树）** — 自动重新平衡

自动重新组织自身以保持 O(log n) 保证，即使在插入/删除后。

```javascript
// 红黑树：颜色规则确保平衡
// AVL 树：高度差 ≤ 1

// 两者都保证：插入 = O(log n)、删除 = O(log n)、搜索 = O(log n)
```

**优势**：O(log n) 性能保证  
**成本**：每次修改都有重新平衡开销

### 3. **堆** — 父子优先级关系

一个完整的二叉树，其中父节点总是比子节点优先级高。

```javascript
// 大顶堆：       // 小顶堆：
//      9             1
//     / \           / \
//    7   8         2   3
//   / \           / \
//  3   2         8   9

// 父节点 = 1.5 倍优于子节点
// 根节点总是拥有最好的优先级
```

**优势**：非常快速获取最高/最低优先级  
**完美应用**：优先队列、堆排序

---

## 🌍 简洁的解释

对于喜欢通过隐喻理解概念的人：

| 数据结构 | 简洁定义 | 示例 |
|---------|--------|------|
| **链表** | 一条兔子队列，每只兔子拉着前面兔子的尾巴。要找名叫 Pablo 的兔子，你必须从第一只兔子开始搜索。如果不是 Pablo，继续跟随下一只兔子的尾巴。所以可能需要搜索 n 次（O(n) 时间复杂度）。如果要在 Pablo 和 Vicky 之间插入一只名叫 Remi 的兔子，非常简单。只需让 Vicky 放开 Pablo 的尾巴，让 Remi 拉住 Pablo 的尾巴，然后让 Vicky 拉住 Remi 的尾巴（O(1) 时间复杂度）。 | 要找到兔子 "Pablo"，从第一只开始跟随尾巴直到找到 |
| **数组** | 一列编号的兔子。要找名叫 Pablo 的兔子，可以直接喊出 Pablo 的号码 0680（通过数组索引直接查找元素，O(1) 时间复杂度）。但如果你不知道 Pablo 的号码，还是需要逐个搜索（O(n) 时间复杂度）。而且，如果要在 Pablo 后面加一只名叫 Vicky 的兔子，需要给 Vicky 后面的所有兔子重新编号（O(n) 时间复杂度）。 | 按索引查找元素是即时的，但在中间插入很慢 |
| **队列** | 一列编号的兔子，第一只兔子的脸上有便签。对于这条有便签的队列，每当我们想从队列前面移除一只兔子时，只需将便签移到下一只兔子的脸上，无需实际移除兔子来避免给后面所有兔子重新编号（移除也是 O(1) 时间复杂度）。对于队列的尾部，我们无需担心，因为添加到尾部的每只新兔子直接获得一个新号码（O(1) 时间复杂度）。 | 以 FIFO 顺序处理项目，从两端高效操作 |
| **双端队列** | 一列分组编号的兔子，有便签粘在第一只上。对于这条队列，我们以组为单位管理它。每次从队列前面移除一只兔子时，只是将便签移到下一只。这样就不需要每次移除时给第一只后面的所有兔子重新编号。只有当一个完整的组都被移除时，才重新分配号码并重新分组。尾部也采用类似处理。这是一种延迟和批量操作的策略，来抵消 Array 数据结构的缺点，即在中间插入或删除时需要移动所有元素。 | 从两端高效移除/插入，带有批处理优化 |
| **栈** | 一条死胡同隧道中的一线兔子，兔子只能从隧道入口（末尾）移除，新兔子也只能从入口（末尾）添加。 | 以 LIFO 顺序处理项目；撤销/重做功能 |
| **二叉树** | 每个节点最多有两个子节点的树。 | 分层数据组织 |
| **二叉搜索树** | 一棵树，左子树的所有节点小于节点，右子树的所有节点大于节点。维护所有操作的 O(log n)。 | 无需重新排序即可高效搜索/插入/删除 |
| **红黑树** | 一个自平衡的二叉搜索树，通过颜色编码规则自动维护平衡。 | 在 Java TreeMap 中使用，保持 O(log n) 保证 |
| **AVL 树** | 一个更严格的自平衡二叉搜索树，对平衡要求比红黑树更严格。 | 最大搜索速度，但插入/删除较慢 |
| **堆** | 一个特殊的二叉树，存储在数组中，其中父节点始终对子节点维持优先级关系。 | 高效的优先队列；堆排序 |
| **字典树** | 用于基于前缀搜索的字符树。 | 自动完成、拼写检查 |
| **图** | 由边连接的顶点（节点）网络。 | 建模关系、网络 |

---

## 迭代器协议设计

### 隐藏的超能力

该库中的每个数据结构都实现了**迭代器协议**：

- ✅ 展开操作符：`[...tree]`
- ✅ for...of 循环：`for (const item of tree)`
- ✅ 解构：`const [a, b, c] = tree`
- ✅ Array.from()：`Array.from(tree)`
- ✅ Set/Map 构造器：`new Set(tree)`

### 迭代器支持对比

| 功能 | Array | Map | Set | 其他库 | data-structure-typed |
|-----|-------|-----|-----|-------|:----:|
| 展开操作符 | ✅ | ❌/⚠️ | ✅ | ❌/⚠️ | ✅ |
| for...of 循环 | ✅ | ✅ | ✅ | ❌/⚠️ | ✅ |
| 解构 | ✅ | ❌ | ❌ | ❌ | ✅ |
| Array.from() | ✅ | ❌/⚠️ | ❌ | ❌/⚠️ | ✅ |
| Set 构造器 | ✅ | ❌ | ✅ | ❌ | ✅ |
| **完整集成** | ✅ | ⚠️ | ⚠️ | ⚠️ | **✅** |

### 实时示例：零摩擦转换

#### 示例 1：数组 → 树 → 数组

```javascript
const array = [64, 34, 25, 12, 22, 11, 90];
const rbTree = new RedBlackTree(array);
const sorted = [...rbTree.keys()];
console.log(sorted);  // [11, 12, 22, 25, 34, 64, 90] ✅
```

#### 示例 2：提取键和值

```javascript
const rbTree = new RedBlackTree([
  [1, 'Alice'],
  [2, 'Bob'],
  [3, 'Charlie']
]);

const allKeys = [...rbTree.keys()];      // [1, 2, 3]
const allValues = [...rbTree.values()];  // ['Alice', 'Bob', 'Charlie']
```

#### 示例 3：在任何结构上 for...of

```javascript
const tree = new RedBlackTree(entries);
const deque = new Deque(items);
const heap = new MaxHeap(items);

for (const entry of tree) console.log(entry);
for (const item of deque) console.log(item);
for (const item of heap) console.log(item);
```

---

## 🔗 无缝互操作性：迭代器协议无处不在

所有线性结构都支持相同的 4 个方法，使得 API 学习成本为零。

---

## 📚 所有数组方法都适用

由于所有结构都实现迭代器协议，您可以使用标准 JavaScript 方法：

```javascript
const tree = new RedBlackTree([5, 2, 8, 1, 9]);

// map
const doubled = tree.map(x => x * 2);

// filter
const filtered = tree.filter(x => x > 5);

// reduce
const sum = tree.reduce((acc, val) => acc + val, 0);

// find
const first = tree.find(x => x > 7);

// some / every
const hasLarge = tree.some(x => x > 100);
```

---

## 为什么不直接用原生 JavaScript？

| 需求 | Array | Set | Map | data-structure-typed |
|-----|-------|-----|-----|:----:|
| 排序 + 快速访问 | ❌ | ❌ | ❌ | ✅ |
| 前 K 元素 | ❌ | ❌ | ❌ | ✅ |
| 自动排序 | ❌ | ❌ | ❌ | ✅ |
| 前缀搜索 | ❌ | ❌ | ❌ | ✅ (Trie) |
| 优先队列 | ❌ | ❌ | ❌ | ✅ |

---

## 🎯 决策指南：选择正确的数据结构

### 快速决策树

```
需要什么？

├─ 按索引直接访问
│  └─ Array
│
├─ 排序 + 频繁更新
│  └─ RedBlackTree
│
├─ 最高/最低值
│  ├─ 堆 (Heap)
│  └─ PriorityQueue
│
├─ 首尾高效操作
│  └─ Deque
│
├─ 前缀匹配
│  └─ Trie
│
├─ 一次排序，多次使用
│  └─ Array.sort()
│
├─ 动态插入，无索引偏移
│  └─ LinkedList
│
└─ 网络/关系
   └─ DirectedGraph / UndirectedGraph
```

---

总结：本库为 TypeScript 开发者提供了生产级别的数据结构，无需学习复杂的新 API，同时提供了明显的性能优势。
